```text
=====================================================
DOCUMENTACIÓN TÉCNICA: PROYECTO "CAJAS DEL CAMPO"
=====================================================

Versión: 1.0
Fecha: 24 de septiembre de 2025

Este documento describe la arquitectura, funcionalidades y especificaciones técnicas para el desarrollo de la aplicación web y móvil "Cajas del Campo".

-------------------------------------------
1. DESCRIPCIÓN GENERAL DEL PROYECTO
-------------------------------------------

"Cajas del Campo" es una plataforma digital que conecta a campesinos y productores locales con consumidores finales a través de un modelo de suscripción de cajas de productos agrícolas.

**Propuesta de Valor:**
- **Para el Cliente:** Ofrecer productos frescos, naturales y a un precio justo, eliminando intermediarios. Brinda la comodidad de recibir una caja de mercado en casa y la satisfacción de apoyar directamente la economía local y el consumo sostenible.
- **Para el Campesino:** Proporcionar un canal de venta directa, asegurando un ingreso más estable y justo por sus productos, y dándoles visibilidad en el mercado digital.

La aplicación funcionará como un e-commerce por suscripción donde los usuarios podrán elegir, personalizar y gestionar la entrega periódica de sus cajas de productos del campo.

-------------------------------------------
2. ARQUITECTURA Y STACK TECNOLÓGICO
-------------------------------------------

La aplicación se desarrollará siguiendo una arquitectura desacoplada con un frontend (cliente) y un backend (servidor) que se comunican a través de una API REST.

**2.1. Arquitectura MVC (Modelo-Vista-Controlador)**

Esta arquitectura se aplicará principalmente en el backend (Node.js) para organizar el código de manera lógica y escalable.

- **Modelo (Model):** Representa la estructura de los datos y la lógica de negocio. Se encargará de interactuar con la base de datos. Aquí se definirán los esquemas de los usuarios, productos, suscripciones, etc. Se utilizará un ORM (Object-Relational Mapping) como Sequelize o un ODM (Object-Document Mapping) como Mongoose para facilitar esta interacción.

- **Vista (View):** Es la representación de los datos, es decir, la interfaz de usuario (UI). En nuestra arquitectura, la "Vista" es manejada completamente por el frontend de React. El backend no renderizará HTML directamente, sino que enviará los datos en formato JSON a React para que este los presente al usuario.

- **Controlador (Controller):** Actúa como intermediario entre el Modelo y la Vista. Recibe las peticiones HTTP del cliente (React), procesa la solicitud (ej: validar datos), interactúa con el Modelo para consultar o modificar la base de datos y envía una respuesta (generalmente en formato JSON) de vuelta a la Vista.

**Flujo de una petición:**
1. El usuario interactúa con la interfaz en React (Vista).
2. React realiza una petición HTTP (ej: GET, POST) a un endpoint específico del backend.
3. El enrutador del backend (Express.js) dirige la petición al Controlador correspondiente.
4. El Controlador procesa la lógica, llama al Modelo para acceder a los datos.
5. El Modelo interactúa con la base de datos y devuelve los datos al Controlador.
6. El Controlador formatea la respuesta y la envía como JSON al cliente (React).
7. React recibe los datos y actualiza la Vista para mostrarlos al usuario.

**2.2. Stack Tecnológico**

- **Frontend (Cliente):**
  - **Framework:** React.js
  - **Lenguaje:** JavaScript / TypeScript (recomendado para escalabilidad).
  - **Gestión de Estado:** React Context API (para aplicaciones simples) o Redux Toolkit (para estado complejo).
  - **Enrutamiento:** React Router.
  - **Peticiones HTTP:** Axios.
  - **Estilos:** Styled-Components, Tailwind CSS o un framework de componentes como Material-UI.

- **Backend (Servidor):**
  - **Entorno de ejecución:** Node.js
  - **Framework:** Express.js (para la creación de la API REST).
  - **Lenguaje:** JavaScript / TypeScript.
  - **Base de Datos:** PostgreSQL (recomendado por su robustez para datos relacionales y transaccionales como ventas y suscripciones).
  - **ORM:** Sequelize (para mapear los modelos de datos de PostgreSQL a objetos en JavaScript/TypeScript).

- **Autenticación:**
  - **Estrategia:** JSON Web Tokens (JWT) para gestionar sesiones seguras.
  - **OAuth 2.0:** Integración con Google para "Iniciar Sesión con Google".

-------------------------------------------
3. FUNCIONALIDADES DE LA APLICACIÓN
-------------------------------------------

**3.1. Módulo de Usuario (Cliente)**

1.  **Autenticación y Registro:**
    -   Registro mediante formulario de correo y contraseña.
    -   Inicio de sesión con credenciales.
    -   Inicio de sesión/registro rápido con Google (OAuth 2.0).
    -   Funcionalidad de "Olvidé mi contraseña" vía email.

2.  **Gestión de Perfil:**
    -   El usuario podrá ver y modificar su información personal: nombre, apellido, teléfono.
    -   Gestionar múltiples direcciones de envío.
    -   Administrar sus métodos de pago (CRUD): asociar nuevas tarjetas, PSE, y otros medios a través de una pasarela de pago.

3.  **Suscripciones:**
    -   Explorar los diferentes tipos de "cajas" o planes de suscripción disponibles.
    -   Suscribirse a un plan, seleccionando frecuencia de entrega (semanal, quincenal, mensual).
    -   Ver el historial de sus suscripciones activas y pasadas.
    -   Pausar, cancelar o reactivar una suscripción.
    -   Ver detalles de su próxima entrega.

4.  **Pagos:**
    -   Integración con una pasarela de pagos (ej. PayU, Stripe) que soporte:
        -   Tarjetas de crédito/débito.
        -   PSE (Pagos Seguros en Línea).
        -   Google Pay.
        -   Factura de Claro (si la pasarela de pago lo permite como método de pago alternativo).
    -   Visualización del historial de pagos y facturas.

**3.2. Módulo de Administración (Admin)**

Este módulo será una interfaz web accesible solo para personal autorizado.

1.  **Dashboard (Panel de Control):**
    -   Visualización de métricas clave en tiempo real:
        -   Ingresos totales (diarios, semanales, mensuales).
        -   Número de suscriptores activos.
        -   Nuevas suscripciones vs. cancelaciones.
        -   Productos más vendidos.
    -   Gráficos y reportes para el análisis de ventas.

2.  **Gestión de Clientes (CRUD):**
    -   Ver un listado de todos los clientes registrados.
    -   Buscar y filtrar clientes por nombre, correo, etc.
    -   Ver los detalles de un cliente específico (información personal, direcciones, historial de suscripciones y pedidos).
    -   Desactivar o eliminar cuentas de clientes.

3.  **Gestión de Campesinos (CRUD):**
    -   Añadir nuevos campesinos a la plataforma.
    -   Editar la información de los campesinos (nombre, ubicación, historia, datos de contacto).
    -   Asociar productos a cada campesino.

4.  **Gestión de Productos (CRUD):**
    -   Crear nuevos productos (ej: Tomate, Lechuga, Papa).
    -   Editar detalles del producto (nombre, descripción, unidad de medida, precio base).
    -   Asignar productos a uno o varios campesinos.
    -   Gestionar el stock o la disponibilidad por temporada.

5.  **Gestión de Suscripciones (CRUD):**
    -   Ver todas las suscripciones de la plataforma.
    -   Modificar manualmente la suscripción de un cliente (ej: cambiar plan, actualizar fecha de entrega).
    -   Crear suscripciones manualmente para un cliente.
    -   Cancelar suscripciones a petición del cliente.

-------------------------------------------
4. DISEÑO DE LA BASE DE DATOS (POSTGRESQL)
-------------------------------------------

**4.1. Modelo Entidad-Relación**

El modelo se basará en las siguientes entidades principales y sus relaciones:

- Un `User` puede tener una o muchas `Subscriptions`.
- Un `User` puede tener una o muchas `Addresses`.
- Un `Subscription` está asociada a un `User`.
- Un `Subscription` genera muchos `Orders` (uno por cada ciclo de entrega).
- Un `Order` está asociado a una `Subscription` y a un `User`.
- Un `Order` contiene muchos `Products` (a través de una tabla intermedia `Order_Items`).
- Un `Product` puede estar en muchos `Orders` (a través de `Order_Items`).
- Un `Farmer` puede proveer muchos `Products`.
- Cada `Order` tiene asociado un `Payment`.

**4.2. Descripción de Tablas Principales**

-   `Users`
    -   `user_id` (PK, SERIAL)
    -   `name` (VARCHAR)
    -   `email` (VARCHAR, UNIQUE)
    -   `password_hash` (VARCHAR)
    -   `google_id` (VARCHAR, NULLABLE, UNIQUE)
    -   `phone_number` (VARCHAR, NULLABLE)
    -   `role` (VARCHAR, 'customer' o 'admin')
    -   `created_at` (TIMESTAMP)

-   `Addresses`
    -   `address_id` (PK, SERIAL)
    -   `user_id` (FK a `Users`)
    -   `address_line1` (VARCHAR)
    -   `city` (VARCHAR)
    -   `department` (VARCHAR)
    -   `details` (TEXT, NULLABLE)
    -   `is_default` (BOOLEAN)

-   `Farmers`
    -   `farmer_id` (PK, SERIAL)
    -   `name` (VARCHAR)
    -   `story` (TEXT)
    -   `location` (VARCHAR)
    -   `contact_info` (VARCHAR)

-   `Products`
    -   `product_id` (PK, SERIAL)
    -   `farmer_id` (FK a `Farmers`)
    -   `name` (VARCHAR)
    -   `description` (TEXT)
    -   `price` (DECIMAL)
    -   `unit` (VARCHAR, ej: 'kg', 'unidad')
    -   `image_url` (VARCHAR)

-   `Subscriptions`
    -   `subscription_id` (PK, SERIAL)
    -   `user_id` (FK a `Users`)
    -   `plan_name` (VARCHAR, ej: 'Caja Pequeña')
    -   `frequency` (VARCHAR, ej: 'weekly', 'monthly')
    -   `status` (VARCHAR, ej: 'active', 'paused', 'cancelled')
    -   `start_date` (DATE)
    -   `next_delivery_date` (DATE)
    -   `price` (DECIMAL)

-   `Orders`
    -   `order_id` (PK, SERIAL)
    -   `user_id` (FK a `Users`)
    -   `subscription_id` (FK a `Subscriptions`)
    -   `address_id` (FK a `Addresses`)
    -   `order_date` (TIMESTAMP)
    -   `delivery_date` (DATE)
    -   `total_amount` (DECIMAL)
    -   `status` (VARCHAR, ej: 'pending', 'shipped', 'delivered')

-   `Order_Items` (Tabla intermedia para relación Muchos-a-Muchos)
    -   `order_item_id` (PK, SERIAL)
    -   `order_id` (FK a `Orders`)
    -   `product_id` (FK a `Products`)
    -   `quantity` (INTEGER)
    -   `price_at_purchase` (DECIMAL)

-   `Payments`
    -   `payment_id` (PK, SERIAL)
    -   `order_id` (FK a `Orders`)
    -   `amount` (DECIMAL)
    -   `payment_method` (VARCHAR)
    -   `transaction_id` (VARCHAR, de la pasarela de pago)
    -   `status` (VARCHAR, ej: 'completed', 'failed')
    -   `payment_date` (TIMESTAMP)

-------------------------------------------
5. CONSIDERACIONES DE SEGURIDAD
-------------------------------------------

La seguridad es un pilar fundamental del proyecto.

1.  **Autenticación y Autorización:**
    -   Usar JWT con una firma segura (HS256) y un tiempo de expiración corto. Implementar un mecanismo de refresh token.
    -   Implementar control de acceso basado en roles (RBAC). Los endpoints de administración deben estar protegidos y solo ser accesibles para usuarios con rol 'admin'.

2.  **Protección de Datos:**
    -   **NUNCA** almacenar contraseñas en texto plano. Usar un algoritmo de hashing fuerte como `bcrypt`.
    -   Utilizar HTTPS (SSL/TLS) en toda la comunicación entre cliente y servidor para encriptar los datos en tránsito.
    -   **NUNCA** almacenar datos completos de tarjetas de crédito. Delegar el 100% de esta responsabilidad a la pasarela de pago (que debe ser compatible con PCI-DSS) y solo almacenar un token o una referencia al método de pago.

3.  **Seguridad del Backend (API):**
    -   **Validación de entradas:** Validar y sanear todos los datos que llegan del cliente para prevenir ataques de Inyección SQL, NoSQL, y Cross-Site Scripting (XSS). Usar librerías como `express-validator`.
    -   **CORS:** Configurar una política de Cross-Origin Resource Sharing (CORS) estricta para permitir peticiones solo desde el dominio de nuestra aplicación frontend.
    -   **Seguridad de Cabeceras:** Usar `Helmet.js` para establecer cabeceras HTTP seguras.
    -   **Rate Limiting:** Implementar un limitador de peticiones para prevenir ataques de fuerza bruta en el login y ataques de denegación de servicio (DoS).

-------------------------------------------
6. ESTRATEGIA DE PRUEBAS (TESTING)
-------------------------------------------

Se debe implementar un plan de pruebas robusto para garantizar la calidad y estabilidad de la aplicación.

**6.1. Pruebas de Rendimiento**

-   **Objetivo:** Asegurar que la aplicación pueda manejar una carga de usuarios concurrentes sin degradar el rendimiento.
-   **Pruebas de Carga:** Simular el acceso de N usuarios simultáneos a las funcionalidades clave (login, ver productos, procesar suscripción) para medir tiempos de respuesta y uso de CPU/Memoria del servidor.
-   **Pruebas de Estrés:** Aumentar progresivamente la carga hasta encontrar el punto de quiebre de la aplicación para identificar cuellos de botella.
-   **Herramientas:** Apache JMeter, k6, Artillery.

**6.2. Pruebas de Seguridad**

-   **Objetivo:** Identificar y corregir vulnerabilidades de seguridad.
-   **Análisis Estático (SAST):** Utilizar herramientas que escaneen el código fuente en busca de patrones de vulnerabilidades conocidos.
-   **Análisis Dinámico (DAST):** Probar la aplicación en ejecución para encontrar vulnerabilidades como las del top 10 de OWASP.
-   **Pruebas de Penetración (Pentesting):** Realizar un ataque simulado para explotar debilidades en la arquitectura, la API y la configuración del servidor.
-   **Herramientas:** OWASP ZAP, Burp Suite, SonarQube.

**6.3. Otras Pruebas Esenciales**

-   **Pruebas Unitarias:** Probar las funciones y componentes más pequeños de forma aislada. (Jest, Mocha).
-   **Pruebas de Integración:** Verificar que diferentes partes del sistema (ej: Controlador y Modelo) funcionan correctamente juntas.
-   **Pruebas End-to-End (E2E):** Automatizar flujos de usuario completos en un navegador real para simular la interacción real del usuario. (Cypress, Playwright).

-------------------------------------------
7. CAMBIOS/CONSIDERACIONES/ADICIONES
-------------------------------------------

**OBSERVACIONES Y MEJORAS IMPLEMENTADAS:**

1. **Arquitectura y Estructura del Proyecto:**
   - Se implementó una arquitectura de microservicios con separación clara entre frontend (React) y backend (Node.js/Express)
   - Se agregó un sistema de contextos para manejo de estado global en React
   - Se implementó un sistema de rutas protegidas con autenticación JWT
   - Se agregó un sistema de validación de formularios con react-hook-form

2. **Base de Datos y Modelos:**
   - Se agregaron campos adicionales a los modelos existentes:
     - `is_active` en Users y Farmers para soft delete
     - `email_verified` en Users para verificación de email
     - `years_experience` y `specialties` en Farmers
     - `organic` y `nutritional_info` en Products
     - `box_size` y `custom_preferences` en Subscriptions
   - Se implementaron hooks de Sequelize para validaciones automáticas
   - Se agregaron métodos de instancia para validación de contraseñas

3. **Seguridad:**
   - Se implementó rate limiting para prevenir ataques de fuerza bruta
   - Se agregó validación de entrada con express-validator
   - Se implementó sanitización de datos de entrada
   - Se agregó middleware de CORS configurado
   - Se implementó hashing de contraseñas con bcrypt
   - Se agregó sistema de refresh tokens para mayor seguridad

4. **API y Endpoints:**
   - Se implementaron todos los endpoints especificados
   - Se agregaron endpoints adicionales para:
     - Búsqueda y filtrado de productos
     - Estadísticas de campesinos
     - Gestión de direcciones de usuarios
     - Dashboard administrativo con métricas
   - Se implementó paginación en todos los endpoints de listado
   - Se agregó sistema de respuestas estandarizadas

5. **Frontend y UX/UI:**
   - Se implementó un diseño responsive con Material-UI
   - Se agregó animaciones con Framer Motion
   - Se implementó un sistema de notificaciones con react-hot-toast
   - Se agregó un sistema de carga y estados de error
   - Se implementó un sistema de búsqueda y filtros avanzados
   - Se agregó un sistema de confirmación para acciones críticas

6. **Funcionalidades Adicionales:**
   - Sistema de búsqueda en tiempo real
   - Filtros por categoría, precio, disponibilidad
   - Sistema de favoritos (preparado para implementación)
   - Sistema de notificaciones push (preparado para implementación)
   - Sistema de reviews y calificaciones (preparado para implementación)
   - Sistema de cupones y descuentos (preparado para implementación)

7. **Mejoras en la Experiencia del Usuario:**
   - Se implementó un sistema de navegación intuitivo
   - Se agregó un sistema de breadcrumbs
   - Se implementó un sistema de ayuda contextual
   - Se agregó un sistema de feedback visual para todas las acciones
   - Se implementó un sistema de carga progresiva

8. **Optimizaciones de Rendimiento:**
   - Se implementó lazy loading para componentes
   - Se agregó memoización para componentes pesados
   - Se implementó debouncing para búsquedas
   - Se agregó compresión de imágenes
   - Se implementó cache de consultas frecuentes

9. **Consideraciones de Escalabilidad:**
   - Se preparó la arquitectura para microservicios
   - Se implementó un sistema de logs estructurados
   - Se agregó monitoreo de performance
   - Se implementó un sistema de métricas de negocio
   - Se preparó la infraestructura para CDN

10. **Mejoras en la Seguridad:**
    - Se implementó validación de JWT con expiración
    - Se agregó sanitización de datos de entrada
    - Se implementó rate limiting por IP
    - Se agregó validación de roles y permisos
    - Se implementó logging de actividades de seguridad

**FUNCIONALIDADES IMPLEMENTADAS EN ESTA ACTUALIZACIÓN:**

1. **Integración de Pagos:**
   ✅ Integración completa con Stripe
   ✅ Componente de pago con Stripe Elements
   ✅ Procesamiento de pagos con tarjeta de crédito/débito
   ✅ Sistema de confirmación de pagos
   ✅ Interfaz de usuario para historial de pagos
   ✅ Manejo de errores y estados de pago

2. **Sistema de Suscripciones:**
   ✅ Conexión completa del frontend con la API
   ✅ Gestión de suscripciones desde el panel de administración
   ✅ Actualización de base de datos en tiempo real
   ✅ Pausar, reanudar y cancelar suscripciones
   ✅ Creación de nuevas suscripciones

3. **Edición de Productos:**
   ✅ Interfaz completa de edición de productos
   ✅ Formularios de creación y edición
   ✅ Validación de datos
   ✅ Asociación con campesinos
   ✅ Gestión de stock y disponibilidad

4. **Configuración para Producción:**
   ✅ Configuración de Docker para producción
   ✅ Docker Compose para servicios múltiples
   ✅ Configuración de Nginx con SSL
   ✅ Variables de entorno para producción
   ✅ Script de monitoreo del sistema
   ✅ Configuración de seguridad

**FUNCIONALIDADES PENDIENTES DE IMPLEMENTACIÓN:**

1. **Integración de Pagos Adicionales:**
   - Integración con PayU
   - Sistema de webhooks para confirmación de pagos
   - Sistema de reembolsos automáticos
   - Integración con Google Pay

2. **Sistema de Notificaciones:**
   - Notificaciones por email
   - Notificaciones push
   - Notificaciones SMS
   - Sistema de templates de notificaciones

3. **Sistema de Logística:**
   - Integración con servicios de envío
   - Sistema de tracking de pedidos
   - Optimización de rutas de entrega
   - Sistema de alertas de entrega

4. **Sistema de Analytics:**
   - Dashboard de métricas en tiempo real
   - Reportes de ventas
   - Análisis de comportamiento del usuario
   - Métricas de rendimiento

5. **Sistema de Testing:**
   - Pruebas unitarias
   - Pruebas de integración
   - Pruebas end-to-end
   - Pruebas de rendimiento

6. **Sistema de Monitoreo Avanzado:**
   - Monitoreo de errores en tiempo real
   - Dashboard de salud del sistema
   - Alertas automáticas por email/SMS
   - Métricas de negocio

**RECOMENDACIONES PARA PRODUCCIÓN:**

1. **Infraestructura:**
   - Usar un servicio de base de datos gestionado (AWS RDS, Google Cloud SQL)
   - Implementar un CDN para assets estáticos
   - Usar un servicio de cache (Redis)
   - Implementar un sistema de colas para tareas asíncronas

2. **Seguridad:**
   - Implementar HTTPS en toda la aplicación
   - Usar un WAF (Web Application Firewall)
   - Implementar un sistema de backup automático
   - Usar un servicio de gestión de secretos

3. **Monitoreo:**
   - Implementar APM (Application Performance Monitoring)
   - Usar un servicio de logging centralizado
   - Implementar alertas automáticas
   - Usar un servicio de métricas de negocio

4. **Escalabilidad:**
   - Implementar load balancing
   - Usar un servicio de auto-scaling
   - Implementar un sistema de cache distribuido
   - Usar un servicio de colas de mensajes

**INSTRUCCIONES DE DESPLIEGUE EN PRODUCCIÓN:**

1. **Preparación del Entorno:**
   ```bash
   # Clonar el repositorio
   git clone <repository-url>
   cd CajasDelCampo
   
   # Configurar variables de entorno
   cp env.production .env
   # Editar .env con los valores reales de producción
   
   # Instalar dependencias
   npm install
   cd frontend && npm install && cd ..
   ```

2. **Configuración de Base de Datos:**
   ```bash
   # Crear base de datos PostgreSQL
   createdb cajas_del_campo
   
   # Ejecutar migraciones
   npm run migrate
   
   # Crear usuario administrador
   node create-admin.js
   ```

3. **Despliegue con Docker:**
   ```bash
   # Construir imágenes
   docker-compose -f docker-compose.prod.yml build
   
   # Iniciar servicios
   docker-compose -f docker-compose.prod.yml up -d
   
   # Verificar estado
   docker-compose -f docker-compose.prod.yml ps
   ```

4. **Configuración de SSL:**
   ```bash
   # Obtener certificados SSL (Let's Encrypt)
   certbot --nginx -d your-domain.com
   
   # Configurar renovación automática
   crontab -e
   # Agregar: 0 12 * * * /usr/bin/certbot renew --quiet
   ```

5. **Monitoreo:**
   ```bash
   # Iniciar monitoreo del sistema
   node scripts/monitor.js
   
   # Verificar logs
   docker-compose -f docker-compose.prod.yml logs -f
   ```

6. **Backup de Base de Datos:**
   ```bash
   # Crear backup
   pg_dump -h localhost -U postgres cajas_del_campo > backup_$(date +%Y%m%d_%H%M%S).sql
   
   # Restaurar backup
   psql -h localhost -U postgres cajas_del_campo < backup_file.sql
   ```

**CONFIGURACIÓN DE VARIABLES DE ENTORNO CRÍTICAS:**

```env
# Base de datos
DB_PASSWORD=password_super_seguro_aqui
JWT_SECRET=clave_jwt_muy_segura_y_larga_aqui

# Stripe (usar claves de producción)
STRIPE_SECRET_KEY=sk_live_...
STRIPE_PUBLISHABLE_KEY=pk_live_...

# Email
EMAIL_USER=tu_email@gmail.com
EMAIL_PASSWORD=tu_app_password_aqui
```

**CHECKLIST DE SEGURIDAD PRE-DESPLIEGUE:**

- [ ] Cambiar todas las contraseñas por defecto
- [ ] Configurar SSL/TLS
- [ ] Habilitar firewall
- [ ] Configurar backup automático
- [ ] Establecer monitoreo de logs
- [ ] Configurar alertas de seguridad
- [ ] Revisar permisos de archivos
- [ ] Actualizar dependencias
- [ ] Configurar rate limiting
- [ ] Habilitar CORS apropiadamente

```